<tool id="Add_a_column1" name="Compute" version="2.0">
    <description>an expression on every row</description>
    <macros>
        <xml name="compute_repeat">
            <repeat name="expressions" title="Expressions" min="1" default="1">
                <param name="cond" type="text" value="c3-c2" label="Add expression">
                    <sanitizer>
                        <valid initial="default">
                            <add value="&lt;" />
                            <add value="&gt;" />
                            <add value="&quot;" />
                            <add value="&apos;" />
                        </valid>
                    </sanitizer>
                </param>
                <conditional name="add_column">
                    <param name="mode" type="select" label="Mode of the operation">
                        <option value="">Append</option>
                        <option value="I">Insert</option>
                        <option value="R">Replace</option>
                    </param>
                    <when value="">
                        <param name="pos" type="hidden" value="" />
                    </when>
                    <when value="I">
                        <param name="pos" type="integer" min="1" value="1" label="Insert new column before existing column number" />
                    </when>
                    <when value="R">
                        <param name="pos" type="integer" min="1" value="1" label="Use new column to replace column number" />
                    </when>
                </conditional>
                <yield />
            </repeat>
        </xml>
    </macros>
    <requirements>
        <requirement type="package" version="3.8">python</requirement>
        <requirement type="package" version="1.23.1">numpy</requirement>
    </requirements>
    <command detect_errors="aggressive"><![CDATA[
python '$__tool_directory__/column_maker.py'
--column-types $input.metadata.column_types
$avoid_scientific_notation
#if str($ops.header_lines_select) == 'yes':
    --header
#end if
--file '$expressions_file'
$error_handling.fail_on_non_existent_columns
$error_handling.non_computable.action
#if str($error_handling.non_computable.action) == '--non-computable-default':
    '$error_handling.non_computable.default_value'
#end if
'$input'
'$out_file1'
    ]]></command>
    <configfiles>
      <configfile name="expressions_file"><![CDATA[
#if str($ops.header_lines_select) == 'yes':
    #for $expr in $ops.expressions:
${expr.cond};${expr.add_column.pos}${expr.add_column.mode};${expr.new_column_name}
    #end for
#else:
    #for $expr in $ops.expressions:
${expr.cond};${expr.add_column.pos}${expr.add_column.mode};
    #end for
#end if
]]></configfile>
    </configfiles>
    <inputs>
        <param name="input" type="data" format="tabular" label="Input file" help="Dataset missing? See TIP below"/>
        <conditional name="ops">
            <param name="header_lines_select" type="select"
            label="Input has a header line with column names?"
            help="Select Yes to be able to specify names for new columns and have them added to the header line. If you select No, the first line will be treated as a regular line: If it is empty or starts with a # character it will be skipped, otherwise the tool will attempt to compute the specified expression on it." >
                <option value="no">No</option>
                <option value="yes">Yes</option>
            </param>
            <when value="no">
                <expand macro="compute_repeat" />
            </when>
            <when value="yes">
                <expand macro="compute_repeat">
                    <param name="new_column_name" type="text" value="New Column" label="The new column name" />
                </expand>
            </when>
        </conditional>
        <param name="avoid_scientific_notation" type="boolean" truevalue="--avoid-scientific-notation" falsevalue=""
        label="Avoid scientific notation in any newly computed columns"
        help="If yes, use fully expanded decimal representation when writing new columns with floating point values. To prevent scientific notation in just specific new columns, you can use numpy's format_float_positional function in the corresponding expression." />
        <section name="error_handling" title="Error handling">
            <param argument="--fail-on-non-existent-columns" type="boolean" truevalue="--fail-on-non-existent-columns" falsevalue="" checked="true" label="Fail on references to non-existent columns"
            help="If any expression references a column number that does not exist when that expression gets computed, the tool run will fail. Uncheck to have such a situation handled as a case of a non-computable expression as configured below." />
            <conditional name="non_computable">
                <param name="action" type="select" label="If an expression cannot be computed for a row">
                    <option value="--skip-non-computable">Skip the row</option>
                    <option value="--keep-non-computable">Keep the row unchanged</option>
                    <option value="--non-computable-blank">Produce an empty column value for the row</option>
                    <option value="--non-computable-default">Fill in a replacement value</option>
                    <option value="--fail-on-non-computable">Fail the entire tool run</option>
                </param>
                <when value="--skip-non-computable" />
                <when value="--keep-non-computable" />
                <when value="--non-computable-blank" />
                <when value="--fail-on-non-computable" />
                <when value="--non-computable-default">
                    <param name="default_value" type="text" label="Replacement value" help="Pick from suggestions or enter your own.">
                        <option value="nan">nan (not a number)</option>
                        <option value="inf">inf (infinity)</option>
                        <option value="-inf">-inf (negative infinity)</option>
                        <option value="NA">NA (not available)</option>
                        <option value=".">.</option>
                    </param>
                </when>
            </conditional>
        </section>
    </inputs>
    <outputs>
        <data name="out_file1" format_source="input" metadata_source="input"/>
    </outputs>
    <tests>
        <test>
            <param name="cond" value="float(c3-c2)"/>
            <param name="input" value="1.bed"/>
            <output name="out_file1" file="column_maker_out1.interval"/>
        </test>
        <test>
            <param name="cond" value="c4*1."/>
            <param name="input" value="1.interval"/>
            <output name="out_file1" file="column_maker_out2.interval"/>
        </test>
        <test>
            <param name="cond" value="c4*1."/>
            <param name="input" value="1.header.tsv"/>
            <param name="header_lines_select" value="yes" />
            <param name="new_column_name" value="value1_again" />
            <output name="out_file1" file="column_maker_out2.header.tsv"/>
        </test>
        <test>
            <param name="cond" value="round(c4*1)"/>
            <param name="input" value="1.interval"/>
            <output name="out_file1" file="column_maker_out3.interval"/>
        </test>
        <test>
             <!-- test that single column input works -->
             <param name="cond" value="c1/10"/>
             <param name="input" value="1.tab" ftype="tabular"/>
             <output name="out_file1" file="column_maker_out4.tab"/>
         </test>
         <test>
            <param name="cond" value="float(.0000000000001)"/>
            <param name="input" value="1.bed"/>
            <output name="out_file1">
                <assert_contents>
                    <has_text text="CCDS10397" />
                    <has_text text="1e-13" />
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="cond" value="float(.0000000000001)"/>
            <param name="input" value="1.bed"/>
            <param name="avoid_scientific_notation" value="true"/>
            <output name="out_file1">
                <assert_contents>
                    <has_text text="CCDS10397" />
                    <has_text text=".0000000000001" />
                    <not_has_text text="1e-13" />
                </assert_contents>
            </output>
        </test>
        <test>
            <param name="input" value="1.tab" ftype="tabular"/>
            <repeat name="expressions">
                <param name="cond" value="c1/10" />
                <conditional name="add_column">
                    <param name="mode" value="R" />
                    <param name="pos" value="1" />
                </conditional>
            </repeat>
            <repeat name="expressions">
                <param name="cond" value="round(c1*10)" />
                <conditional name="add_column">
                    <param name="mode" value="I" />
                    <param name="pos" value="1" />
                </conditional>
            </repeat>
            <output name="out_file1" file="column_maker_out4.tab"/>
        </test>
    </tests>
    <help><![CDATA[
 .. class:: infomark

**TIP:** If your data is not TAB delimited, use *Text Manipulation->Convert*

-----

**What it does**

This tool computes an expression for every row of a dataset and appends or inserts the result as a new column (field). Several expressions can be specified and will be applied sequentially to each row.

- Columns are referenced with **c** and a **number**. For example, **c1** refers to the first column of a tab-delimited file

- **c3-c2** will add a length column to the dataset if **c2** and **c3** are start and end position

-----

**Example**

If this is your input::

   chr1  151077881  151077918  2  200  -
   chr1  151081985  151082078  3  500  +

computing "c4*c5" will produce::

   chr1  151077881  151077918  2  200  -   400
   chr1  151081985  151082078  3  500  +  1500

You can also use this tool to evaluate expressions. For example, computing "c3>=c2" for Input will result in the following::

   chr1  151077881  151077918  2  200  -  True
   chr1  151081985  151082078  3  500  +  True

or computing "type(c2)==type('') for Input will return::

   chr1  151077881  151077918  2  200  -  False
   chr1  151081985  151082078  3  500  +  False


The following built-in Python functions are available::

  abs | all | any | bin | bool | chr | ceil | cmp | complex

  divmod | exp | float | log | log10 | floor | hex | int | len | long

  max | min | oct | ord | pow | range | reversed

  round | sorted | sqrt | str | sum | type | unichr | unicode

In addition the numpy function `format_float_positional` is available.
    ]]></help>
    <citations />
</tool>
